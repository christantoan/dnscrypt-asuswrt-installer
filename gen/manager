#!/bin/sh

[ -f /jffs/dnscrypt/.config ] && . /jffs/dnscrypt/.config

NAME="$(basename "$0")[$$]"

append_on_demand () {
  local TARGET
  local LINE
  TARGET="$1"
  shift
  for LINE in "$@"; do
    if ! grep -qF "$LINE" "$TARGET"; then
      printf "%s\n" "$LINE" >> "$TARGET"
    fi
  done
}

check_dns_environment () {
  local NVCHECK
  NVCHECK="0"
  if [ "$(nvram get dnspriv_enable)" != "0" ]; then { nvram set dnspriv_enable="0"; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$(pidof stubby)" ]; then { killall -q -9 stubby 2>/dev/null; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$(nvram get dhcp_dns1_x)" ]; then { nvram set dhcp_dns1_x=""; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$(nvram get dhcp_dns2_x)" ]; then { nvram set dhcp_dns2_x=""; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$(nvram get dhcpd_dns_router)" != "1" ]; then { nvram set dhcpd_dns_router="1"; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$NVCHECK" != "0" ]; then { nvram commit; }; { service restart_dnsmasq >/dev/null 2>&1; }; while { [ "$(ping 1.1.1.1 -c1 -W2 >/dev/null 2>&1; printf "%s" "$?")" = "0" ] && [ "$(nslookup google.com 127.0.0.1 >/dev/null 2>&1; printf "%s" "$?")" != "0" ]; }; do sleep 1; done; fi
}

dnsmasq_params () {
  local DNS
  local VAR
  if { [ "$(nvram get dns_local_cache)" != "1" ] && [ "$(readlink -f /tmp/resolv.conf)" = "/rom/etc/resolv.conf" ]; }; then { umount /tmp/resolv.conf 2>/dev/null; }; fi
  [ -z "$(pidof dnscrypt-proxy)" ] && exit
  cp -a /tmp/resolv.dnsmasq /jffs/dnscrypt/resolv.dnsmasq
  append_on_demand /etc/dnsmasq.conf "no-resolv"
  append_on_demand /jffs/dnscrypt/resolv.dnsmasq "server=127.0.1.1"
  if [ "$(nvram get dns_local_cache)" != "1" ]; then { mount -o bind /rom/etc/resolv.conf /tmp/resolv.conf; }; fi
  for DNS in $(nvram get wan_dns) $(nvram get wan0_dns) $(nvram get wan1_dns) $(nvram get wan_dns1_x) $(nvram get wan_dns2_x) $(nvram get wan0_dns1_x) $(nvram get wan0_dns2_x) $(nvram get wan1_dns1_x) $(nvram get wan1_dns2_x) $(nvram get wan0_xdns) $(nvram get wan1_xdns) $(nvram get ipv6_get_dns); do
  sed -i "/^server=$DNS.*$/d" /jffs/dnscrypt/resolv.dnsmasq
  done
  for VAR in 1 2 3; do
  DNS="$(nvram get "ipv6_dns$VAR")"
  [ -n "$DNS" ] && sed -i "/^server=$DNS.*$/d" /jffs/dnscrypt/resolv.dnsmasq
  done
  sed -i "/^servers-file=.*$/d" /etc/dnsmasq.conf
  append_on_demand /etc/dnsmasq.conf "servers-file=/jffs/dnscrypt/resolv.dnsmasq"
}

init_hwrng () {
  local COUNT
  COUNT="0"
  while [ ! -c "$RNG_DEV" ]; do
    if [ "$COUNT" -gt 120 ]; then
      logger -st "$NAME" "ERROR: Unable to find HWRNG device. Aborting..."
      if [ -f "/jffs/dnscrypt/haveged" ]; then { /jffs/dnscrypt/haveged -w 1024 -d 32 -i 32 -v 1; }; logger -st "$NAME" "Haveged: Using available haveged instead..."; fi
      exit 1
    fi
    COUNT="$((COUNT+1))"
    sleep 1
  done
  { /jffs/dnscrypt/stty raw -echo -ixoff -F "$RNG_DEV" speed 115200; };
  { /jffs/dnscrypt/rngd -r "$RNG_DEV"; };
  [ $? -eq 0 ] && logger -st "$NAME" "rngd: Started for $RNG_DEV"
}

start_dnscrypt () {
  local COUNTER
  local LIMIT
  local STATE
  local NW_STATE
  local RES_STATE
  local DNSCRYPT_START
  { cd /jffs/dnscrypt; } || exit
  { killall -s 9 "$(pidof dnscrypt-proxy)" 2>/dev/null || killall -q -9 dnscrypt-proxy 2>/dev/null; };
  DNSCRYPT_START="/jffs/dnscrypt/dnscrypt-proxy -syslog -config /jffs/dnscrypt/dnscrypt-proxy.toml"
  logger -st "$NAME" "Starting dnscrypt-proxy from $NAME."
  { nohup $DNSCRYPT_START >/dev/null 2>&1 </dev/null & };
  COUNTER="0";
  LIMIT="10";
  { while [ -z "$(pidof dnscrypt-proxy)" ] && [ "$COUNTER" -le "$LIMIT" ]; do sleep 1; COUNTER="$((COUNTER + 1))"; done; };
  if ! grep -qF "servers-file=/jffs/dnscrypt/resolv.dnsmasq" "/etc/dnsmasq.conf"; then { service restart_dnsmasq >/dev/null 2>&1; }; fi
  STATE="0"
  [ -z "$1" ] && NW_STATE="$(ping 1.1.1.1 -c1 -W2 >/dev/null 2>&1; printf "%s" "$?")"
  [ -z "$1" ] && RES_STATE="$(nslookup google.com 127.0.0.1 >/dev/null 2>&1; printf "%s" "$?")"
  [ -z "$1" ] && while { [ "$NW_STATE" = "0" ] && [ "$RES_STATE" != "0" ] && [ "$STATE" -lt "10" ]; }; do sleep 1; NW_STATE="$(ping 1.1.1.1 -c1 -W2 >/dev/null 2>&1; printf "%s" "$?")"; RES_STATE="$(nslookup google.com 127.0.0.1 >/dev/null 2>&1; printf "%s" "$?")"; STATE="$((STATE + 1))"; done
  [ "$STATE" -eq "10" ] && start_dnscrypt x
}

stop_dnscrypt () {
  local COUNTER
  local LIMIT
  { cd /jffs/dnscrypt; } || exit
  { killall -s 9 "$(pidof dnscrypt-proxy)" 2>/dev/null || killall -q -9 dnscrypt-proxy 2>/dev/null; };
  COUNTER="0";
  LIMIT="10";
  { while [ -n "$(pidof dnscrypt-proxy)" ] && [ "$COUNTER" -le "$LIMIT" ]; do sleep 1; COUNTER="$((COUNTER + 1))"; done; };
  if grep -qF "servers-file=/jffs/dnscrypt/resolv.dnsmasq" "/etc/dnsmasq.conf"; then { service restart_dnsmasq >/dev/null 2>&1; }; fi
}

start_monitor () {
  trap "" 1 2 3 6 15
  trap 'EXIT="1"' 10
  while [ "$(nvram get ntp_ready)" -eq 0 ]; do sleep 1; done
  local NW_STATE
  local RES_STATE
  local COUNT
  local EXIT
  local RANDOM
  COUNT="0"
  EXIT="0"
  RANDOM="0"
  logger -st "$NAME" "Starting_Monitor: $NAME"
  while true; do
    if [ "$EXIT" = "1" ]; then logger -st "$NAME" "Stopping_Monitor: $NAME"; trap - 1 2 3 6 10 15; stop_dnscrypt; break; fi
    if [ "$COUNT" -gt 90 ]; then COUNT="0"; timezone; "$0" opendns-update; fi
    COUNT="$((COUNT + 1))"
    if [ -f "/jffs/dnscrypt/dnscrypt-proxy" ]; then
      case "$COUNT" in
        "30"|"60"|"90")
          timezone
          "$0" opendns-update
          NW_STATE="$(ping 1.1.1.1 -c1 -W2 >/dev/null 2>&1; printf "%s" "$?")"
          RES_STATE="$(nslookup google.com 127.0.0.1 >/dev/null 2>&1; printf "%s" "$?")"
          ;;
      esac
      if [ -z "$(pidof dnscrypt-proxy)" ]; then
        logger -st "$NAME" "Warning: dnscrypt-proxy is dead; $NAME will start it!"
        start_dnscrypt
      elif { [ "$COUNT" -eq "30" ] || [ "$COUNT" -eq "60" ] || [ "$COUNT" -eq "90" ]; } && { [ "$NW_STATE" = "0" ] && [ "$RES_STATE" != "0" ]; }; then
        logger -st "$NAME" "Warning: dnscrypt-proxy is not responding; $NAME will re-start it!"
        start_dnscrypt
      elif [ "$RANDOM" -eq 4320 ]; then
        RANDOM="0"
        logger -st "$NAME" "Randomization: Health Check; $NAME will randomize it!"
        start_dnscrypt
      fi
      RANDOM="$((RANDOM + 1))"
    fi
    sleep 10
  done
}

stop_monitor () {
  for PID in $(pidof "$(basename "$0")"); do if { awk '{ print }' "/proc/${PID}/cmdline" | grep -q dnscrypt; } && [ "$PID" != "$$" ]; then { kill -s 10 "$PID" 2>/dev/null || kill -s 9 "$PID" 2>/dev/null; }; fi; done
}

timezone () {
  local SANITY
  local NOW
  local TIMEZONE
  local TARGET
  local LINK
  SANITY="$(date -u -r "$0" '+%s')"
  NOW="$(date -u '+%s')"
  TIMEZONE="/jffs/dnscrypt/localtime"
  TARGET="/etc/localtime"
  LINK="$(readlink "$TARGET")"
  if [ -f "$TIMEZONE" ] && [ "$LINK" = "$TIMEZONE" ]; then
    [ "$NOW" -ge "$SANITY" ] && { touch "$0"; };
  elif [ -f "$TIMEZONE" ]; then
    ln -sf $TIMEZONE $TARGET
    [ "$NOW" -le "$SANITY" ] && { date -u -s "$(date -u -r "$0" '+%Y-%m-%d %H:%M:%S')"; };
  fi
}

update_opendns () {
  if [ -z "$OPENDNS_USER" ] || [ -z  "$OPENDNS_PASSWORD" ] || [ "$1" -gt 2 ]; then
    return
  fi
  sleep 5
  RET="$(curl -k -s -u "$OPENDNS_USER:$OPENDNS_PASSWORD" "https://updates.opendns.com/nic/update?hostname=")"
  case "$RET" in
    good*)
      logger -st "$NAME" "OpenDNS: Update IP succeeded"
      ;;
    badauth*)
      logger -st "$NAME" "OpenDNS: Wrong username or password"
      ;;
    *)
      logger -st "$NAME" "OpenDNS: Received error $RET"
      update_opendns "$(($1+1))"
      ;;
  esac
}

unset TZ
case "$1" in
  "dnsmasq")
    dnsmasq_params
    ;;
  "start"|"restart"|"dnscrypt-start")
    if [ -z "$(pidof dnscrypt-proxy)" ]; then { "$0" init-start >/dev/null 2>&1; }; else { start_dnscrypt >/dev/null 2>&1; }; fi
    ;;
  "stop"|"kill"|"dnscrypt-stop")
    { "$0" services-stop >/dev/null 2>&1; };
    ;;
  "monitor-start")
    stop_monitor && { start_monitor & };
    ;;
  "opendns-update")
    update_opendns 0 &
    ;;
  "init-start"|"services-stop")
    timezone
    if [ -n "$RAN_PRV" ]; then { kill -s 9 "$(pidof haveged jitterentropy-rngd rngd stty)" 2>/dev/null || killall -q -9 haveged jitterentropy-rngd rngd stty 2>/dev/null; }; fi
    if [ "$1" = "init-start" ]; then
      { printf "1" > /proc/sys/vm/overcommit_memory; };
      case "$RAN_PRV" in
        "haveged")
          { /jffs/dnscrypt/haveged -w 1024 -d 32 -i 32 -v 1; };
          ;;
        "rngd")
          init_hwrng &
          ;;
      esac
      { "$0" monitor-start; };
    elif [ "$1" = "services-stop" ]; then
      { stop_monitor; };
    fi
    ;;
esac
check_dns_environment
